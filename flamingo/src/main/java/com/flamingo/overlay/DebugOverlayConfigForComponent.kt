package com.flamingo.overlay

import androidx.annotation.VisibleForTesting
import androidx.compose.runtime.Composable
import androidx.compose.runtime.ReadOnlyComposable
import androidx.compose.runtime.remember
import com.flamingo.Flamingo

/**
 * @return [DebugOverlay.Config] of a flamingo component with [componentFunName] function name or
 * null, if [Flamingo.LocalDebugOverlay] is null
 */
@Composable
@ReadOnlyComposable
public fun Flamingo.debugOverlayConfigForComponent(componentFunName: String): DebugOverlay.Config? {
    val overlay = LocalDebugOverlay.current ?: return null
    return overlay.getConfig(componentFunName)
}

/**
 * Returns [DebugOverlay.Config] for a component, automatically determining its qualified name.
 *
 * Function is `internal` because of its instability.
 *
 * @param callDepth if 0, function is called directly from the component's function body. If
 * greater - from other functions, that are called in component's function body. Number of
 * intermediate functions MUST BE equal to [callDepth]
 *
 * @see debugOverlayConfigForComponent
 */
@Composable
internal fun debugOverlayConfigForComponent(callDepth: Int): DebugOverlay.Config? {
    val overlay = Flamingo.LocalDebugOverlay.current ?: return null
    val componentFunName = remember { componentFunName(callDepth + 1) }
    return overlay.getConfig(componentFunName)
}

/**
 * This function is slow, do not call it in production.
 *
 * @param callDepth if 0, function is called directly from the component's function body. If
 * greater - from other functions, that are called in component's function body. Number of
 * intermediate functions MUST BE equal to [callDepth]
 *
 * @return fully qualified name of the flamingo component's function
 */
internal fun componentFunName(callDepth: Int): String {
    /** `-` is autogenerated by kotlin compiler, e.g. `IconButton--4fdg5` */
    return currentFunctionName(callDepth = callDepth + 1).substringBefore('-')
}

/**
 * This function is slow, do not call it in production.
 *
 * @param callDepth if > 0, [currentFunctionName] will return the name of the [callDepth]th function
 * in the callstack
 *
 * @return fully qualified name of the function, in which [currentFunctionName] is called, or
 * "no name", if this operation is unsuccessful
 */
@VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
internal fun currentFunctionName(callDepth: Int): String = runCatching {
    val stackTraceElement = Throwable().stackTrace[callDepth + 1]
    return stackTraceElement.className.dropLastWhile { it != '.' } + stackTraceElement.methodName
}.getOrElse {
    throw IllegalStateException("Failed to acquire current function name", it)
}
